use crate::ast::*;

grammar;

pub Algorithm: Algorithm = {
    <statements:Statement*> => Algorithm::Body{statements},
};

pub Statement: Statement = {
    #[precedence(level="0")]

    "let" <lhs:Expression> "=" <rhs:Expression> ";" => Statement::Declare{lhs, rhs, dt: DeclarationType::Var},
    "const" <lhs:Expression> "=" <rhs:Expression> ";" => Statement::Declare{lhs, rhs, dt: DeclarationType::Const},

    #[precedence(level="1")] #[assoc(side="left")]

    <expression: Expression> ";" => Statement::Expression{expression}

    };

pub Expression: Expression = {
    #[precedence(level="0")] 

    <value:IntLiteral> => Expression::Int{value},
    <name:Identifier> => Expression::Var{name},
    "!" <expression:Expression> => Expression::UnaryOp{op: UnaryOp::Not, expr: Box::new(expression)},
    "`" <expression:Expression> => Expression::UnaryOp{op: UnaryOp::Dereference, expr: Box::new(expression)},
    
    #[precedence(level="1")] #[assoc(side="left")]

    <lhs:Expression> "*" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::Mul, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expression> "/" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::Div, lhs: Box::new(lhs), rhs: Box::new(rhs)},

    #[precedence(level="2")] #[assoc(side="left")]
    
    <lhs:Expression> "+" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::Sum, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expression> "-" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::Sub, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expression> "==" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::EQ, lhs: Box::new(lhs), rhs: Box::new(rhs)}

    
};

Identifier: String = {
    <s:r"[_a-zA-Z][_a-zA-Z0-9]*"> => s.to_string(),
};

IntLiteral: i64 = {
    <s:r"[0-9]+"> => s.parse().unwrap(),
};

match {
    r"\s*" => {},
    r"#[^\n\r]*[\n\r]*" => {},
    _,
}