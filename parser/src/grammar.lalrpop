use crate::ast::*;
use crate::errors::LexError;
use crate::lexer::location::Location as LexLocation;
use crate::lexer::token::TokenKind;
grammar;

pub Algorithm: Algorithm = {
    <lines:FileLine*> => Algorithm::Body(lines)
};

pub FileLine: FileLine = {
         <labels: LabelsDeclaration?> <statements:Statements> "END_OF_FILE"=> { 
        match labels {
                        Some(labels) => FileLine::Line{labels, statements: statements},
                        None => FileLine::Line{labels: vec![], statements: statements}
                    }
                },
        <labels: LabelsDeclaration?> <statements:Statements> "NEW_LINE"=> { 
        match labels {
                        Some(labels) => FileLine::Line{labels, statements: statements},
                        None => FileLine::Line{labels: vec![], statements: statements}
                    }
                },
};

pub LabelsDeclaration: Vec<String> = {
    <labels: Labels> "..." => labels
};

#[inline]
Labels: Vec<String> = { // (1)
    <mut v:(<Identifier> ",")*> <e:Identifier?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub OneLineStatement: OneLineStatement = {
    CallSubProgram,
    UnconditionalJump,
    Loop,
    Predicate,
    "!" => OneLineStatement::Exit,
    "RETURN" => OneLineStatement::Return
};

pub CallSubProgram: OneLineStatement = {
    "SUB_PROGRAM" <sp_name: Identifier> "{" <args: Parameters> "}" <label_to: Identifier>  => {
        OneLineStatement::SubProgram{
            sp_name
          , args: args.into_iter().map(Box::new).collect()
          , label_to
        }
}
};

pub Predicate: OneLineStatement = {
    "PREDICATE" "{" <condition:ExpressionPrecedence8> "}" <l:Statements> "|" <r:Statements> => {
        OneLineStatement::Predicate{
            condition
          , if_true: Box::new(l)
          , if_false: Box::new(r)}
        }
};

pub Loop: OneLineStatement = {
    "LOOP" "{" <a:Expression> "," <b:Expression> "," <c:Expression>  "=>" <e: Expression> "}" <alpha: Identifier> <betta: Identifier> => OneLineStatement::Loop{
        initial_value: a
      , step: b
      , last_value_or_condition: c
      , iterator: e
      , label_until: alpha, 
      label_to: betta }

};

pub UnconditionalJump: OneLineStatement = {
    "@" <label: Identifier> => OneLineStatement::UnconditionalJump{label},
};

pub SimpleStatement: SimpleStatement = {
    <lhs:Expression> "=" <rhs:Expression> => SimpleStatement::Assign{lhs, rhs},
    <lhs:Expression> "<=>" <rhs:Expression> => SimpleStatement::Exchange{lhs, rhs},
    <lhs:Expression> "=>" <rhs:Expression> => SimpleStatement::Send{lhs: rhs,rhs: lhs},
    <expression: Expression> => SimpleStatement::Expression{expression},
    };


pub Expression: Expression = {
    ExpressionPrecedence8,
    };

ExpressionPrecedence8: Expression = {
    <lhs:ExpressionPrecedence8> "OR" <rhs:ExpressionPrecedence7> => Expression::BinaryOp{op: BinaryOp::Or, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    ExpressionPrecedence7,
};

ExpressionPrecedence7: Expression = {
    <lhs:ExpressionPrecedence7> "AND" <rhs:ExpressionPrecedence6> => Expression::BinaryOp{op: BinaryOp::And, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    ExpressionPrecedence6,
};

ExpressionPrecedence6: Expression = {
    <lhs:ExpressionPrecedence6> "==" <rhs:ExpressionPrecedence5> => Expression::BinaryOp{op: BinaryOp::EQ, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:ExpressionPrecedence6> "!=" <rhs:ExpressionPrecedence5> => Expression::BinaryOp{op: BinaryOp::NE, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:ExpressionPrecedence6> "<" <rhs:ExpressionPrecedence5> => Expression::BinaryOp{op: BinaryOp::LT, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    ExpressionPrecedence5
}

// ArithmeticExpression
ExpressionPrecedence5: Expression = {
    <lhs:ExpressionPrecedence5> "+" <rhs:ExpressionPrecedence4> => Expression::BinaryOp{op: BinaryOp::Sum, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:ExpressionPrecedence5> "-" <rhs:ExpressionPrecedence4> => Expression::BinaryOp{op: BinaryOp::Sub, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    ExpressionPrecedence4
}

// FactorExpression
ExpressionPrecedence4: Expression = {
    <lhs:ExpressionPrecedence4> "*" <rhs:ExpressionPrecedence3> => Expression::BinaryOp{op: BinaryOp::Mul, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:ExpressionPrecedence4> "/" <rhs:ExpressionPrecedence3> => Expression::BinaryOp{op: BinaryOp::Div, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    ExpressionPrecedence3
};

ExpressionPrecedence3: Expression = {
    ExpressionPrecedence2
}

ExpressionPrecedence2: Expression = {
    "NOT" <expression:ExpressionPrecedence2> => Expression::UnaryOp{op: UnaryOp::Not, expr: Box::new(expression)},
    "'" <expression:ExpressionPrecedence2> => Expression::UnaryOp{op: UnaryOp::Dereference, expr: Box::new(expression)},
    ExpressionPrecedence1
}

ExpressionPrecedence1: Expression = {
    LiteralExpression,
    FunctionCall,
    Variable,
    "(" <Expression> ")",

};

LiteralExpression: Expression = {
    BoolLiteral,
    IntLiteral,
    StringLiteral,
    FloatLiteral,
    NullLiteral
};

FunctionCall: Expression = {
    <function: "IDENTIFIER"> "{" <args: Parameters> "}" => Expression::Call{function, args: args.into_iter().map(Box::new).collect()},
}

#[inline]
Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

#[inline]
Semicolon<T>: Vec<T> = { // (1)
    <mut v:(<T> ";")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
#[inline]
Statements: Statements = {
    <statements: Semicolon<SimpleStatement>> => Statements::SimpleStatements(statements),
    <statement:OneLineStatement> => Statements::OneLineStatement(statement)
};

#[inline]
SimpleStatements = Semicolon<SimpleStatement>;

#[inline]
Parameters = Comma<Expression>;

Variable: Expression = {
    <name:"IDENTIFIER"> => Expression::Var{name}
}

NullLiteral: Expression = {
    <n:"NULL"> => Expression::Null,
};


IntLiteral: Expression = {
    <n:"INTEGER_LITERAL"> => Expression::Int{value: n},
};

FloatLiteral: Expression = {
    <n:"FLOAT_LITERAL"> => Expression::Float{value: n},
}

BoolLiteral: Expression = {
    "TRUE" => Expression::Bool{value: true},
    "FALSE" => Expression::Bool{value: false},

};

StringLiteral: Expression = {
    <s: "STRING_LITERAL"> => Expression::String{value: s}
};

Identifier: String = {
    <i: "IDENTIFIER"> => i
};

extern {
    type Location = LexLocation;
    type Error = LexError;

    enum TokenKind {
    "IDENTIFIER" => TokenKind::Identifier (<String>),
    "INTEGER_LITERAL" => TokenKind::IntegerLiteral (<i64>),
    "FLOAT_LITERAL" => TokenKind::FloatLiteral (<f64>),
    "STRING_LITERAL" => TokenKind::StringLiteral (<String>),
    "NEW_LINE" => TokenKind::NewLine,
    "END_OF_FILE" => TokenKind::EndOfFile,
    "(" => TokenKind::LeftParenthesis,
        ")" => TokenKind::RightParenthesis,
        "[" => TokenKind::LeftSquareBracket,
        "]" => TokenKind::RightSquareBracket,
        ":" => TokenKind::Colon,
        "," => TokenKind::Comma,
        ";" => TokenKind::Semicolon,
        "*" => TokenKind::Multiply,
        "+" => TokenKind::Plus,
        "-" => TokenKind::Minus,
        "/" => TokenKind::Slash,
        "|" => TokenKind::VerticalBar, // '|'
        "&" => TokenKind::Ampersand,    // '&'
        "<" => TokenKind::LessThan,
        ">" => TokenKind::GreaterThan,
        "=" => TokenKind::Equal,
        "." => TokenKind::Dot,
        "%" => TokenKind::Percent,
        "{" => TokenKind::LeftCurlyBrace,
        "}" => TokenKind::RightCurlyBrace,
        "==" => TokenKind::EqualEqual,
        "!=" => TokenKind::NotEqual,
        "=<" => TokenKind::LessThanEqual,
        ">=" => TokenKind::GreaterThanEqual,
        ">>" => TokenKind::RightShift,
        "<<" => TokenKind::LeftShift,
        "//" => TokenKind::DoubleSlash,
        "=>" => TokenKind::Send,
        "..." => TokenKind::Ellipsis,
        "'" => TokenKind::Apostrophe,
        "<=>" => TokenKind::Exchange,
        "REPLACE" => TokenKind::Replace,
        "LOOP" => TokenKind::Loop,
        "PREDICATE" => TokenKind::Predicate,
        "SUB_PROGRAM" =>TokenKind::SubProgram,
        "@" => TokenKind::At,
        "!" => TokenKind::Bang,
        "RETURN" => TokenKind::Return,
        "FALSE" => TokenKind::False,
        "NULL" => TokenKind::Null,
        "TRUE" => TokenKind::True,
        "AND" => TokenKind::And,
        "DEL" => TokenKind::Del,
        "NOT" => TokenKind::Not,
        "OR" => TokenKind::Or,
        "LET" => TokenKind::Let,
        "CONST" => TokenKind::Const,
    }
}