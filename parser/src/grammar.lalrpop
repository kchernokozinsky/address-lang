use crate::ast::*;
use crate::lexer::LexError;
use crate::lexer::location::Location as LexLocation;
use crate::lexer::token::Token;
grammar;

pub Algorithm: Algorithm = {
    <statements:Statement*> => Algorithm::Body{statements},
};

pub Statement: Statement = {
    #[precedence(level="0")]

    "LET" <lhs:Expression> "=" <rhs:Expression> ";"   => Statement::Declare{lhs, rhs, dt: DeclarationType::Var},
    "CONST" <lhs:Expression> "=" <rhs:Expression> ";" => Statement::Declare{lhs, rhs, dt: DeclarationType::Const},
    <lhs:Expression> "<=>" <rhs:Expression> ";"       => Statement::Replace{lhs, rhs},
    <lhs:Expression> "=>" <rhs:Expression> ";"        => Statement::Assign{lhs: rhs,rhs: lhs},
    <lhs:Expression> "=" <rhs:Expression> ";"         => Statement::Assign{lhs, rhs},

    #[precedence(level="1")] #[assoc(side="left")]

    <expression: Expression> ";" => Statement::Expression{expression},
    "!"  ";"                     => Statement::Exit
    };

pub Expression: Expression = {
    #[precedence(level="0")] 
    Term,
    <name:"IDENTIFIER"> => Expression::Var{name},
    "NOT" <expression:Expression> => Expression::UnaryOp{op: UnaryOp::Not, expr: Box::new(expression)},
    "'" <expression:Expression> => Expression::UnaryOp{op: UnaryOp::Dereference, expr: Box::new(expression)},
    <function: "IDENTIFIER"> "(" <args: Arg> ")" => Expression::Call{function, args: vec![Box::new(args)]},
    #[precedence(level="1")] #[assoc(side="left")]

    <lhs:Expression> "*" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::Mul, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expression> "/" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::Div, lhs: Box::new(lhs), rhs: Box::new(rhs)},

    #[precedence(level="2")] #[assoc(side="left")]
    
    <lhs:Expression> "+" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::Sum, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expression> "-" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::Sub, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expression> "==" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::EQ, lhs: Box::new(lhs), rhs: Box::new(rhs)},
};

Term: Expression = {
    <value:IntLiteral> => Expression::Int{value},
    "(" <Expression> ")"
};

Arg: Expression = {
    Expression,
};

IntLiteral: i64 = {
    <n:"INTEGER_LITERAL"> => n,
};

extern {
    type Location = LexLocation;
    type Error = LexError;

    enum Token {
    "IDENTIFIER" => Token::IDENTIFIER (<String>),
    "INTEGER_LITERAL" => Token::INTEGER_LITERAL (<i64>),
    "FLOAT_LITERAL" => Token::FLOAT_LITERAL (<f64>),
    "STRING_LITERAL" => Token::STRING_LITERAL (<String>),
    "NEW_LINE" => Token::NEW_LINE,
    "END_OF_FILE" => Token::END_OF_FILE,
    "(" => Token::LEFT_PARENTHESIS,
    ")" => Token::RIGHT_PARENTHESIS,
    "[" => Token::LEFT_SQUARE_BRACKET,
    "]" => Token::RIGHT_SQUARE_BRACKET,
    ":" => Token::COLON,
    "," => Token::COMMA,
    ";" => Token::SEMICOLON,
    "*" => Token::OPERATOR_MULTIPLY,
    "+" => Token::OPERATOR_PLUS,
    "-" => Token::OPERATOR_MINUS,
    "/" => Token::OPERATOR_SLASH,
    "|" => Token::OPERATOR_VERTICAL_BAR, // '|'
    "&" => Token::OPERATOR_AMPERSAND,    // '&'
    "<" => Token::OPERATOR_LESS_THAN,
    ">" => Token::OPERATOR_GREATER_THAN,
    "=" => Token::OPERATOR_EQUAL,
    "." => Token::OPERATOR_DOT,
    "%" => Token::OPERATOR_PERCENT,
    "{" => Token::LEFT_CURLY_BRACE,
    "}" => Token::RIGHT_CURLY_BRACE,
    "==" => Token::OPERATOR_EQUAL_EQUAL,
    "!=" => Token::OPERATOR_NOT_EQUAL,
    "=<" => Token::OPERATOR_LESS_THAN_EQUAL,
    ">=" => Token::OPERATOR_GREATER_THAN_EQUAL,
    ">>" => Token::OPERATOR_LEFT_SHIFT,
    "<<" => Token::OPERATOR_RIGHT_SHIFT,
    "//" => Token::OPERATOR_DOUBLE_SLASH, // '//'
    "=>" => Token::OPERATOR_RIGHT_ARROW,
    "..." => Token::OPERATOR_ELLIPSIS,
    "'" => Token::OPERATOR_APOSTROPHE,
    "<=>" => Token::OPERATOR_REPLACE,
    "LOOP" => Token::LOOP,
    "PREDICATE" => Token::PREDICATE,
    "!" => Token::BANG,

    // Basic Keywords:
    "FALSE" => Token::FALSE,
    "NULL" => Token::NULL,
    "TRUE" => Token::TRUE,
    "AND" => Token::AND,
    "DEL" => Token::DEL,
    "NOT" => Token::NOT,
    "OR" => Token::OR,
    "LET" => Token::LET,
    "CONST" => Token::CONST,
}
}