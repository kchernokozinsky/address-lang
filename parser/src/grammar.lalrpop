use crate::ast::*;

grammar;

pub Algorithm: Algorithm = {
    <statements:Statement*> => Algorithm::Body{statements},
};

pub Statement: Statement = {
    #[precedence(level="0")]

    "let" <lhs:Expression> "=" <rhs:Expression> ";"   => Statement::Declare{lhs, rhs, dt: DeclarationType::Var},
    "const" <lhs:Expression> "=" <rhs:Expression> ";" => Statement::Declare{lhs, rhs, dt: DeclarationType::Const},
    <lhs:Expression> "<=>" <rhs:Expression> ";"       => Statement::Replace{lhs, rhs},
    <lhs:Expression> "=>" <rhs:Expression> ";"        => Statement::Assign{lhs: rhs,rhs: lhs},
    <lhs:Expression> "=" <rhs:Expression> ";"         => Statement::Assign{lhs, rhs},

    #[precedence(level="1")] #[assoc(side="left")]

    <expression: Expression> ";" => Statement::Expression{expression},
    "!"  ";"                     => Statement::Exit
    };

pub Expression: Expression = {
    #[precedence(level="0")] 
    Term,
    <name:Identifier> => Expression::Var{name},
    "not" <expression:Expression> => Expression::UnaryOp{op: UnaryOp::Not, expr: Box::new(expression)},
    "`" <expression:Expression> => Expression::UnaryOp{op: UnaryOp::Dereference, expr: Box::new(expression)},
    <function: Identifier> "(" <args: Arg> ")" => Expression::Call{function, args: vec![Box::new(args)]},
    #[precedence(level="1")] #[assoc(side="left")]

    <lhs:Expression> "*" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::Mul, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expression> "/" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::Div, lhs: Box::new(lhs), rhs: Box::new(rhs)},

    #[precedence(level="2")] #[assoc(side="left")]
    
    <lhs:Expression> "+" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::Sum, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expression> "-" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::Sub, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expression> "==" <rhs:Expression> => Expression::BinaryOp{op: BinaryOp::EQ, lhs: Box::new(lhs), rhs: Box::new(rhs)},
};

Term: Expression = {
    <value:IntLiteral> => Expression::Int{value},
    "(" <Expression> ")"
};

Arg: Expression = {
    Expression,
};

Identifier: String = {
    <s:r"[_a-zA-Z][_a-zA-Z0-9]*"> => s.to_string(),
};

IntLiteral: i64 = {
    <s:r"[0-9]+"> => s.parse().unwrap(),
};

match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _
}