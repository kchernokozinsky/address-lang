use crate::ast::*;
use crate::lexer::LexError;
use crate::lexer::location::Location as LexLocation;
use crate::lexer::token::Token;
grammar;

pub Algorithm: Algorithm = {
    <lines:FileLine*> => Algorithm::Body{lines},
};

pub FileLine: FileLine = {

        // FormulaLine,
        CommonLine
};

pub FormulaLine: FileLine = {
         <labels: LabelsDeclaration?> <statement:OneLineStatement> "END_OF_FILE"=> { 
        match labels {
                        Some(labels) => FileLine::FormulaLine{labels, statement},
                        None => FileLine::FormulaLine{labels: vec![], statement}
                    }
                },
        <labels: LabelsDeclaration?> <statement:OneLineStatement> "NEW_LINE"=> { 
        match labels {
                        Some(labels) => FileLine::FormulaLine{labels, statement},
                        None => FileLine::FormulaLine{labels: vec![], statement}
                    }
                },
}

pub CommonLine: FileLine = {
        <labels: LabelsDeclaration?> <statements:Statements> "NEW_LINE"=> { 
        match labels {
                        Some(labels) => FileLine::Line{labels, statements},
                        None => FileLine::Line{labels: vec![], statements}
                    }
                },
    <labels: LabelsDeclaration?> <statements:Statements> "END_OF_FILE"=> { 
        match labels {
                        Some(labels) => FileLine::Line{labels, statements},
                        None => FileLine::Line{labels: vec![], statements}
                    }
                },
};


pub LabelsDeclaration: Vec<String> = {
    <labels: Labels> "..." => labels
};

#[inline]
Labels: Vec<String> = { // (1)
    <mut v:(<Identifier> ",")*> <e:Identifier?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
pub OneLineStatement: OneLineStatement = {
    UnconditionalJump,
    Loop
};


pub Loop: OneLineStatement = {
    "LOOP" "{" <a:Expression> "," <b:Expression> "," <c:Expression> "}" <alpha: Identifier> <betta: Identifier> => OneLineStatement::Loop{
        initial_value: a
      , step: b
      , last_value: c
      , label_unitl: alpha, 
      label_to: betta }
};

pub UnconditionalJump: OneLineStatement = {
    <label: Identifier> => OneLineStatement::UnconditionalJump{label},
};

pub Statement: Statement = {
    <lhs:Expression> "=" <rhs:Expression> => Statement::Assign{lhs, rhs},
    <lhs:Expression> "<=>" <rhs:Expression> => Statement::Exchange{lhs, rhs},
    <lhs:Expression> "=>" <rhs:Expression> => Statement::Send{lhs: rhs,rhs: lhs},
    "!"                     => Statement::Exit,
    <expression: Expression> => Statement::Expression{expression},
    };



pub Expression: Expression = {
    BinaryOperator
};

BinaryOperator: Expression = {
    <lhs:BinaryOperator> "+" <rhs:FactorExpression> => Expression::BinaryOp{op: BinaryOp::Sum, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:BinaryOperator> "-" <rhs:FactorExpression> => Expression::BinaryOp{op: BinaryOp::Sub, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    FactorExpression
}

FactorExpression: Expression = {
    <lhs:PrimaryExpression> "*" <rhs:FactorExpression> => Expression::BinaryOp{op: BinaryOp::Mul, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:PrimaryExpression> "/" <rhs:FactorExpression> => Expression::BinaryOp{op: BinaryOp::Div, lhs: Box::new(lhs), rhs: Box::new(rhs)}, 
    PrimaryExpression
};

UnaryOperator: Expression = {
    "NOT" <expression:PrimaryExpression> => Expression::UnaryOp{op: UnaryOp::Not, expr: Box::new(expression)},
    "'" <expression:PrimaryExpression> => Expression::UnaryOp{op: UnaryOp::Dereference, expr: Box::new(expression)},
}
#[inline]
Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Parameters = Comma<Expression>;

#[inline]
Semicolon<T>: Vec<T> = { // (1)
    <mut v:(<T> ";")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Statements = Semicolon<Statement>;

FunctionCall: Expression = {
    <function: "IDENTIFIER"> "(" <args: Parameters> ")" => Expression::Call{function, args: args.into_iter().map(Box::new).collect()},
}

PrimaryExpression: Expression = {
    IntLiteral,
    UnaryOperator,
    FunctionCall,
    Variable,
    "(" <Expression> ")",
};

Variable: Expression = {
    <name:"IDENTIFIER"> => Expression::Var{name}
}

IntLiteral: Expression = {
    <n:"INTEGER_LITERAL"> => Expression::Int{value: n},
};

Identifier: String = {
    <i: "IDENTIFIER"> => i
};


extern {
    type Location = LexLocation;
    type Error = LexError;

    enum Token {
    "IDENTIFIER" => Token::IDENTIFIER (<String>),
    "INTEGER_LITERAL" => Token::INTEGER_LITERAL (<i64>),
    "FLOAT_LITERAL" => Token::FLOAT_LITERAL (<f64>),
    "STRING_LITERAL" => Token::STRING_LITERAL (<String>),
    "NEW_LINE" => Token::NEW_LINE,
    "END_OF_FILE" => Token::END_OF_FILE,
    "(" => Token::LEFT_PARENTHESIS,
    ")" => Token::RIGHT_PARENTHESIS,
    "[" => Token::LEFT_SQUARE_BRACKET,
    "]" => Token::RIGHT_SQUARE_BRACKET,
    ":" => Token::COLON,
    "," => Token::COMMA,
    ";" => Token::SEMICOLON,
    "*" => Token::OPERATOR_MULTIPLY,
    "+" => Token::OPERATOR_PLUS,
    "-" => Token::OPERATOR_MINUS,
    "/" => Token::OPERATOR_SLASH,
    "|" => Token::OPERATOR_VERTICAL_BAR, // '|'
    "&" => Token::OPERATOR_AMPERSAND,    // '&'
    "<" => Token::OPERATOR_LESS_THAN,
    ">" => Token::OPERATOR_GREATER_THAN,
    "=" => Token::OPERATOR_EQUAL,
    "." => Token::OPERATOR_DOT,
    "%" => Token::OPERATOR_PERCENT,
    "{" => Token::LEFT_CURLY_BRACE,
    "}" => Token::RIGHT_CURLY_BRACE,
    "==" => Token::OPERATOR_EQUAL_EQUAL,
    "!=" => Token::OPERATOR_NOT_EQUAL,
    "=<" => Token::OPERATOR_LESS_THAN_EQUAL,
    ">=" => Token::OPERATOR_GREATER_THAN_EQUAL,
    ">>" => Token::OPERATOR_LEFT_SHIFT,
    "<<" => Token::OPERATOR_RIGHT_SHIFT,
    "//" => Token::OPERATOR_DOUBLE_SLASH, // '//'
    "=>" => Token::OPERATOR_RIGHT_ARROW,
    "..." => Token::OPERATOR_ELLIPSIS,
    "'" => Token::OPERATOR_APOSTROPHE,
    "<=>" => Token::OPERATOR_REPLACE,
    "LOOP" => Token::LOOP,
    "PREDICATE" => Token::PREDICATE,
    "!" => Token::BANG,

    // Basic Keywords:
    "FALSE" => Token::FALSE,
    "NULL" => Token::NULL,
    "TRUE" => Token::TRUE,
    "AND" => Token::AND,
    "DEL" => Token::DEL,
    "NOT" => Token::NOT,
    "OR" => Token::OR,
    "LET" => Token::LET,
    "CONST" => Token::CONST,
}
}