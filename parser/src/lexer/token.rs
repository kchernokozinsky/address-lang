use std::fmt::{self};

/// Tokens representing basic elements of the address language syntax.
#[derive(Clone, Debug, PartialEq)]
pub enum Token {
    Identifier(String),
    IntegerLiteral(i64),
    FloatLiteral(f64),
    StringLiteral(String),
    NewLine,
    EndOfFile,
    LeftParenthesis,
    RightParenthesis,
    LeftSquareBracket,
    RightSquareBracket,
    Colon,
    Comma,
    Semicolon,
    Multiply,
    Plus,
    Minus,
    Slash,
    VerticalBar, // '|'
    Ampersand,    // '&'
    LessThan,
    GreaterThan,
    Equal,
    Dot,
    Percent,
    LeftCurlyBrace,
    RightCurlyBrace,
    EqualEqual,
    NotEqual,
    LessThanEqual,
    GreaterThanEqual,
    LeftShift,
    RightShift,
    DoubleSlash, // '//'
    Send,
    Ellipsis,
    Apostrophe,
    Replace,
    Exchange,
    Loop,
    Predicate,
    At,
    Bang,

    // Basic Keywords:
    False,
    Null,
    True,
    And,
    Del,
    Not,
    Or,
    Let,
    Const,
}

impl fmt::Display for Token {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use Token::*;

        match self {
            Identifier(value) => write!(f, "{}", value),
            IntegerLiteral(value) => write!(f, "{}", value),
            FloatLiteral(value) => write!(f, "{}", value),
            StringLiteral(value) => write!(f, "\"{}\"", value),
            NewLine => f.write_str("\\n"),
            EndOfFile => f.write_str("EOF"),
            LeftParenthesis => f.write_str("("),
            RightParenthesis => f.write_str(")"),
            LeftSquareBracket => f.write_str("["),
            RightSquareBracket => f.write_str("]"),
            Colon => f.write_str(":"),
            Comma => f.write_str(","),
            Semicolon => f.write_str(";"),
            Multiply => f.write_str("*"),
            Plus => f.write_str("+"),
            Minus => f.write_str("-"),
            Slash => f.write_str("/"),
            VerticalBar => f.write_str("|"),
            Ampersand => f.write_str("&"),
            LessThan => f.write_str("<"),
            GreaterThan => f.write_str(">"),
            Equal => f.write_str("="),
            Dot => f.write_str("."),
            Percent => f.write_str("%"),
            LeftCurlyBrace => f.write_str("{"),
            RightCurlyBrace => f.write_str("}"),
            EqualEqual => f.write_str("=="),
            NotEqual => f.write_str("!="),
            LessThanEqual => f.write_str("<="),
            GreaterThanEqual => f.write_str(">="),
            LeftShift => f.write_str("<<"),
            RightShift => f.write_str(">>"),
            DoubleSlash => f.write_str("//"),
            Send => f.write_str("=>"),
            Exchange => f.write_str("<=>"),
            Ellipsis => f.write_str("..."),
            Apostrophe => f.write_str("'"),
            At => f.write_str("@"),
            Bang => f.write_str("!"),

            // Basic Keywords:
            False => f.write_str("false"),
            Null => f.write_str("null"),
            True => f.write_str("true"),
            And => f.write_str("and"),
            Del => f.write_str("del"),
            Loop => f.write_str("loop"),
            Replace => f.write_str("Replace"),
            Predicate => f.write_str("predicate"), 
            Not => f.write_str("not"),
            Or => f.write_str("or"),
            Let => f.write_str("let"),
            Const => f.write_str("const"),
        }
    }
}
